# This workflow will publish a package to npm on every push
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Node.js Package

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
  release:
    types: [created]
  workflow_dispatch:  # Allows manual trigger from GitHub Actions UI
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: sudo apt-get update && sudo apt-get install -y unixodbc-dev
      - run: npm ci
  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Verify npm token is set
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "ERROR: NPM_TOKEN secret is not set in GitHub repository secrets"
            echo "Please add NPM_TOKEN secret in: Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "✓ NPM_TOKEN secret is configured"
      
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/
      
      - name: Configure npm authentication
        run: |
          # Get package info
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          echo "Configuring authentication for package: $PACKAGE_NAME"
          
          # Get the npmrc file location (setup-node sets NPM_CONFIG_USERCONFIG)
          NPMRC_FILE="${NPM_CONFIG_USERCONFIG:-$HOME/.npmrc}"
          echo "Using npmrc file: $NPMRC_FILE"
          
          # Create .npmrc file with proper configuration
          if [[ "$PACKAGE_NAME" == @* ]]; then
            # Extract scope from scoped package name
            PACKAGE_SCOPE=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            SCOPE_NAME="${PACKAGE_SCOPE#@}"
            echo "Scoped package detected: $PACKAGE_SCOPE"
            
            # Configure scope registry
            npm config set "@${SCOPE_NAME}:registry" https://registry.npmjs.org/
            
            # Add scope registry to npmrc file
            echo "${PACKAGE_SCOPE}:registry=https://registry.npmjs.org/" > "$NPMRC_FILE"
          else
            echo "Unscoped package detected"
            touch "$NPMRC_FILE"
          fi
          
          # Add authentication token
          echo "//registry.npmjs.org/:_authToken=${{secrets.NPM_TOKEN}}" >> "$NPMRC_FILE"
          
          # Verify .npmrc contents (masked)
          echo "Generated .npmrc configuration:"
          cat "$NPMRC_FILE" | sed 's/:[^:]*$/:***/'
          
          # Show npm config to verify
          echo ""
          echo "npm config list:"
          npm config list | grep -E "(registry|@.*:registry)" || true
          
          # Verify authentication
          echo ""
          echo "Verifying npm authentication..."
          if NPM_USER=$(npm whoami 2>&1); then
            echo "✓ Authenticated as: $NPM_USER"
          else
            echo "✗ Authentication failed"
            echo "Error output: $NPM_USER"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify NPM_TOKEN secret is correct in GitHub repository settings"
            echo "2. Ensure token has 'Automation' type with 'publish' permissions"
            echo "3. Verify token belongs to account that owns scope: ${PACKAGE_SCOPE:-N/A}"
            echo "4. Check npmrc file contents:"
            cat "$NPMRC_FILE" | sed 's/:[^:]*$/:***/'
            exit 1
          fi
      - run: sudo apt-get update && sudo apt-get install -y unixodbc-dev
      - name: Auto-increment version based on commits
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Package: $PACKAGE_NAME"
          echo "Current version in package.json: $CURRENT_VERSION"
          
          # Check if package exists on npm and get latest published version
          PUBLISHED_VERSION=""
          if npm view "$PACKAGE_NAME" version 2>/dev/null; then
            PUBLISHED_VERSION=$(npm view "$PACKAGE_NAME" version)
            echo "Latest published version on npm: $PUBLISHED_VERSION"
          else
            echo "Package not found on npm - this is the first publish"
          fi
          
          # Check if this is a manual initialization (workflow_dispatch) for first publish
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -z "$PUBLISHED_VERSION" ]; then
            echo "Manual workflow trigger - first publish, using base version from package.json"
            exit 0  # Skip version bumping for initial publish
          fi
          
          # Get the last commit message to determine version bump type
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Last commit message: $LAST_COMMIT_MSG"
          
          # Determine version bump based on conventional commits or commit message
          VERSION_BUMP="patch"  # Default to patch
          
          if echo "$LAST_COMMIT_MSG" | grep -qiE "^(breaking|BREAKING|major)"; then
            VERSION_BUMP="major"
            echo "Detected: MAJOR version bump (breaking change)"
          elif echo "$LAST_COMMIT_MSG" | grep -qiE "^(feat|feature|add)"; then
            VERSION_BUMP="minor"
            echo "Detected: MINOR version bump (new feature)"
          elif echo "$LAST_COMMIT_MSG" | grep -qiE "^(fix|bugfix|patch|bug)"; then
            VERSION_BUMP="patch"
            echo "Detected: PATCH version bump (bug fix)"
          else
            # If no conventional commit pattern, always increment patch to avoid version conflicts
            echo "No conventional commit pattern found, defaulting to PATCH increment to avoid conflicts"
            VERSION_BUMP="patch"
          fi
          
          # Compare versions to determine base
          # Extract clean versions (remove build metadata and pre-release for comparison)
          CLEAN_CURRENT=$(echo "$CURRENT_VERSION" | sed 's/+.*//' | sed 's/-.*//')
          if [ -n "$PUBLISHED_VERSION" ]; then
            CLEAN_PUBLISHED=$(echo "$PUBLISHED_VERSION" | sed 's/+.*//' | sed 's/-.*//')
            
            # Compare versions using npm's semver comparison
            # If package.json version is higher, use it (manual override)
            if npm version "$CLEAN_CURRENT" --silent 2>/dev/null && \
               npm view "$PACKAGE_NAME@$CLEAN_CURRENT" version 2>/dev/null >/dev/null || \
               node -e "const semver = require('semver'); process.exit(semver.gt('$CLEAN_CURRENT', '$CLEAN_PUBLISHED') ? 0 : 1)" 2>/dev/null; then
              BASE_VERSION="$CURRENT_VERSION"
              echo "Using package.json version as base (higher than published): $BASE_VERSION"
              echo "This allows manual version overrides in package.json"
            else
              BASE_VERSION="$PUBLISHED_VERSION"
              echo "Using published version as base: $BASE_VERSION"
            fi
          else
            BASE_VERSION="$CURRENT_VERSION"
            echo "Using package.json version as base (first publish): $BASE_VERSION"
          fi
          
          # Extract clean version (remove build metadata and pre-release for incrementing)
          CLEAN_VERSION=$(echo "$BASE_VERSION" | sed 's/+.*//' | sed 's/-.*//')
          echo "Clean base version for incrementing: $CLEAN_VERSION"
          
          # Check if package.json version is explicitly set higher - if so, use it directly without incrementing
          if [ "$CLEAN_CURRENT" != "$CLEAN_VERSION" ] && \
             node -e "const semver = require('semver'); process.exit(semver.gt('$CLEAN_CURRENT', '$CLEAN_VERSION') ? 0 : 1)" 2>/dev/null; then
            echo "Package.json version ($CLEAN_CURRENT) is higher than base ($CLEAN_VERSION)"
            echo "Using package.json version directly without auto-increment (manual version override)"
            CLEAN_VERSION="$CLEAN_CURRENT"
            npm pkg set version="${CLEAN_VERSION}"
          else
            # Temporarily set clean version for npm version command
            npm pkg set version="${CLEAN_VERSION}"
            
            # Increment version using npm version (but don't commit to git)
            npm version "$VERSION_BUMP" --no-git-tag-version
          fi
          
          # Get the incremented version
          INCREMENTED_VERSION=$(node -p "require('./package.json').version")
          echo "Incremented version: $INCREMENTED_VERSION"
          
          # Always add build metadata to ensure uniqueness
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          SHORT_SHA=$(git rev-parse --short HEAD)
          FINAL_VERSION="${INCREMENTED_VERSION}+build.${TIMESTAMP}.${SHORT_SHA}"
          npm pkg set version="${FINAL_VERSION}"
          echo "Final version with build metadata: $FINAL_VERSION"
          
          # Verify version is different from published
          if [ -n "$PUBLISHED_VERSION" ]; then
            if [ "$FINAL_VERSION" = "$PUBLISHED_VERSION" ]; then
              echo "ERROR: Final version matches published version!"
              exit 1
            fi
            echo "✓ Version is unique (different from published: $PUBLISHED_VERSION)"
          fi
      - run: npm install
      - name: Verify package info and access
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          NPM_USER=$(npm whoami)
          
          echo "=== Package Information ==="
          echo "Package name: $PACKAGE_NAME"
          echo "Package version: $PACKAGE_VERSION"
          echo "NPM user: $NPM_USER"
          
          if [[ "$PACKAGE_NAME" == @* ]]; then
            PACKAGE_SCOPE=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            EXPECTED_USER="${PACKAGE_SCOPE#@}"
            echo "Package scope: $PACKAGE_SCOPE"
            echo "Expected user/org: $EXPECTED_USER"
            
            # Check if scope matches user
            if [[ "$NPM_USER" != "$EXPECTED_USER" ]] && [[ "$NPM_USER" != *"$EXPECTED_USER"* ]]; then
              echo "⚠️  WARNING: NPM user '$NPM_USER' may not match scope '$PACKAGE_SCOPE'"
              echo "For scoped packages, the npm user must own the scope."
            fi
          fi
          
          echo ""
          echo "Checking if package exists..."
          if npm view "$PACKAGE_NAME" version 2>/dev/null; then
            echo "✓ Package exists on npm"
            echo "Checking publish access..."
            if npm access ls-packages 2>/dev/null | grep -q "$PACKAGE_NAME"; then
              echo "✓ You have publish access to this package"
            else
              echo "⚠️  Package exists but you may not have publish access"
            fi
          else
            echo "Package does not exist (first publish)"
          fi
      - name: Publish to npm
        run: |
          # Try to publish, but handle the case where package doesn't exist (first publish)
          npm publish --access public || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 1 ]; then
              echo "Publish failed. Common causes:"
              echo "1. Package name might be taken by another account"
              echo "2. npm token might not have publish permissions"
              echo "3. Authentication issue - verify npm_token secret is correct"
              exit $EXIT_CODE
            fi
            exit $EXIT_CODE
          }
