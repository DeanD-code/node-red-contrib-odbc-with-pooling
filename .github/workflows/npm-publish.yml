# This workflow will publish a package to npm on every push
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Node.js Package

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
  release:
    types: [created]
  workflow_dispatch:  # Allows manual trigger from GitHub Actions UI
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: sudo apt-get update && sudo apt-get install -y unixodbc-dev
      - run: npm ci
  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Verify npm token is set
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "ERROR: NPM_TOKEN secret is not set in GitHub repository secrets"
            echo "Please add NPM_TOKEN secret in: Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "✓ NPM_TOKEN secret is configured"
      
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/
      
      - name: Configure npm authentication
        run: |
          # Get package info
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          echo "Configuring authentication for package: $PACKAGE_NAME"
          
          # Get the npmrc file location (setup-node sets NPM_CONFIG_USERCONFIG)
          NPMRC_FILE="${NPM_CONFIG_USERCONFIG:-$HOME/.npmrc}"
          echo "Using npmrc file: $NPMRC_FILE"
          
          # Create .npmrc file with proper configuration
          if [[ "$PACKAGE_NAME" == @* ]]; then
            # Extract scope from scoped package name
            PACKAGE_SCOPE=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            SCOPE_NAME="${PACKAGE_SCOPE#@}"
            echo "Scoped package detected: $PACKAGE_SCOPE"
            
            # Configure scope registry
            npm config set "@${SCOPE_NAME}:registry" https://registry.npmjs.org/
            
            # Add scope registry to npmrc file
            echo "${PACKAGE_SCOPE}:registry=https://registry.npmjs.org/" > "$NPMRC_FILE"
          else
            echo "Unscoped package detected"
            touch "$NPMRC_FILE"
          fi
          
          # Add authentication token
          echo "//registry.npmjs.org/:_authToken=${{secrets.NPM_TOKEN}}" >> "$NPMRC_FILE"
          
          # Verify .npmrc contents (masked)
          echo "Generated .npmrc configuration:"
          cat "$NPMRC_FILE" | sed 's/:[^:]*$/:***/'
          
          # Show npm config to verify
          echo ""
          echo "npm config list:"
          npm config list | grep -E "(registry|@.*:registry)" || true
          
          # Verify authentication
          echo ""
          echo "Verifying npm authentication..."
          if NPM_USER=$(npm whoami 2>&1); then
            echo "✓ Authenticated as: $NPM_USER"
          else
            echo "✗ Authentication failed"
            echo "Error output: $NPM_USER"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify NPM_TOKEN secret is correct in GitHub repository settings"
            echo "2. Ensure token has 'Automation' type with 'publish' permissions"
            echo "3. Verify token belongs to account that owns scope: ${PACKAGE_SCOPE:-N/A}"
            echo "4. Check npmrc file contents:"
            cat "$NPMRC_FILE" | sed 's/:[^:]*$/:***/'
            exit 1
          fi
      - run: sudo apt-get update && sudo apt-get install -y unixodbc-dev
      - name: Determine and set version
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Package: $PACKAGE_NAME"
          echo "Current version in package.json: $CURRENT_VERSION"
          
          # Check if package exists on npm and get latest published version
          PUBLISHED_VERSION=""
          if npm view "$PACKAGE_NAME" version 2>/dev/null; then
            PUBLISHED_VERSION=$(npm view "$PACKAGE_NAME" version)
            echo "Latest published version on npm: $PUBLISHED_VERSION"
          else
            echo "Package not found on npm - this is the first publish"
          fi
          
          # Extract clean versions (remove build metadata and pre-release for comparison)
          CLEAN_CURRENT=$(echo "$CURRENT_VERSION" | sed 's/+.*//' | sed 's/-.*//')
          
          # Determine if we should use package.json version directly (manual override)
          USE_PACKAGE_JSON_VERSION=false
          
          if [ -z "$PUBLISHED_VERSION" ]; then
            # First publish - always use package.json
            echo "First publish - using package.json version: $CLEAN_CURRENT"
            USE_PACKAGE_JSON_VERSION=true
            FINAL_BASE_VERSION="$CLEAN_CURRENT"
          else
            CLEAN_PUBLISHED=$(echo "$PUBLISHED_VERSION" | sed 's/+.*//' | sed 's/-.*//')
            
            # Compare versions - try using npm's semver (built into npm), fallback to node with installed semver
            # First try: use npm's built-in version comparison
            if command -v npm &> /dev/null; then
              # Use npm's semver comparison via node_modules/.bin/semver or install it
              if ! npm list semver &>/dev/null; then
                echo "Installing semver for version comparison..."
                npm install semver --no-save --silent 2>/dev/null || true
              fi
            fi
            
            # Use Node.js with semver for reliable version comparison
            VERSION_COMPARE_RESULT=$(node -e "
              try {
                const semver = require('semver');
                const current = '$CLEAN_CURRENT';
                const published = '$CLEAN_PUBLISHED';
                
                if (semver.gt(current, published)) {
                  console.log('HIGHER');
                } else if (semver.eq(current, published)) {
                  console.log('EQUAL');
                } else {
                  console.log('LOWER');
                }
              } catch(e) {
                // Fallback: simple numeric comparison for major.minor.patch
                const v1 = '$CLEAN_CURRENT'.split('.').map(n => parseInt(n, 10));
                const v2 = '$CLEAN_PUBLISHED'.split('.').map(n => parseInt(n, 10));
                for (let i = 0; i < 3; i++) {
                  if (v1[i] > v2[i]) { console.log('HIGHER'); process.exit(0); }
                  if (v1[i] < v2[i]) { console.log('LOWER'); process.exit(0); }
                }
                console.log('EQUAL');
              }
            " 2>/dev/null)
            
            # If that failed, try installing semver first
            if [ -z "$VERSION_COMPARE_RESULT" ]; then
              echo "Installing semver module..."
              npm install semver --no-save --silent
              VERSION_COMPARE_RESULT=$(node -e "
                const semver = require('semver');
                const current = '$CLEAN_CURRENT';
                const published = '$CLEAN_PUBLISHED';
                
                if (semver.gt(current, published)) {
                  console.log('HIGHER');
                } else if (semver.eq(current, published)) {
                  console.log('EQUAL');
                } else {
                  console.log('LOWER');
                }
              ")
            fi
            
            echo "Version comparison: package.json ($CLEAN_CURRENT) vs published ($CLEAN_PUBLISHED) = $VERSION_COMPARE_RESULT"
            
            if [ "$VERSION_COMPARE_RESULT" = "HIGHER" ]; then
              echo "✓ Package.json version is higher - using it as manual override"
              USE_PACKAGE_JSON_VERSION=true
              FINAL_BASE_VERSION="$CLEAN_CURRENT"
            else
              # Published version is higher or equal - use auto-increment logic
              echo "Using published version as base for auto-increment"
              FINAL_BASE_VERSION="$CLEAN_PUBLISHED"
              
              # Get the last commit message to determine version bump type
              LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
              echo "Last commit message: $LAST_COMMIT_MSG"
              
              # Determine version bump based on conventional commits
              VERSION_BUMP="patch"  # Default to patch
              
              if echo "$LAST_COMMIT_MSG" | grep -qiE "^(breaking|BREAKING|major)"; then
                VERSION_BUMP="major"
                echo "Detected: MAJOR version bump (breaking change)"
              elif echo "$LAST_COMMIT_MSG" | grep -qiE "^(feat|feature|add)"; then
                VERSION_BUMP="minor"
                echo "Detected: MINOR version bump (new feature)"
              elif echo "$LAST_COMMIT_MSG" | grep -qiE "^(fix|bugfix|patch|bug)"; then
                VERSION_BUMP="patch"
                echo "Detected: PATCH version bump (bug fix)"
              else
                echo "No conventional commit pattern found, defaulting to PATCH increment"
                VERSION_BUMP="patch"
              fi
              
              # Set base version and increment
              npm pkg set version="${FINAL_BASE_VERSION}"
              npm version "$VERSION_BUMP" --no-git-tag-version
              FINAL_BASE_VERSION=$(node -p "require('./package.json').version")
              echo "Auto-incremented version: $FINAL_BASE_VERSION"
            fi
          fi
          
          # If using package.json version directly, set it (might have been modified by auto-increment above)
          if [ "$USE_PACKAGE_JSON_VERSION" = "true" ]; then
            npm pkg set version="${FINAL_BASE_VERSION}"
            echo "Using package.json version directly: $FINAL_BASE_VERSION"
          fi
          
          # Always add build metadata to ensure uniqueness
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          SHORT_SHA=$(git rev-parse --short HEAD)
          FINAL_VERSION="${FINAL_BASE_VERSION}+build.${TIMESTAMP}.${SHORT_SHA}"
          npm pkg set version="${FINAL_VERSION}"
          echo "Final version with build metadata: $FINAL_VERSION"
          
          # Verify version is different from published
          if [ -n "$PUBLISHED_VERSION" ]; then
            # Compare without build metadata
            CLEAN_FINAL=$(echo "$FINAL_VERSION" | sed 's/+.*//')
            CLEAN_PUB=$(echo "$PUBLISHED_VERSION" | sed 's/+.*//')
            if [ "$CLEAN_FINAL" = "$CLEAN_PUB" ] && [ "$(echo "$FINAL_VERSION" | grep -o '+.*')" = "$(echo "$PUBLISHED_VERSION" | grep -o '+.*')" ]; then
              echo "ERROR: Final version matches published version!"
              exit 1
            fi
            echo "✓ Version is unique (final: $CLEAN_FINAL vs published: $CLEAN_PUB)"
          fi
      - run: npm install
      - name: Verify package info and access
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          NPM_USER=$(npm whoami)
          
          echo "=== Package Information ==="
          echo "Package name: $PACKAGE_NAME"
          echo "Package version: $PACKAGE_VERSION"
          echo "NPM user: $NPM_USER"
          
          if [[ "$PACKAGE_NAME" == @* ]]; then
            PACKAGE_SCOPE=$(echo "$PACKAGE_NAME" | cut -d'/' -f1)
            EXPECTED_USER="${PACKAGE_SCOPE#@}"
            echo "Package scope: $PACKAGE_SCOPE"
            echo "Expected user/org: $EXPECTED_USER"
            
            # Check if scope matches user
            if [[ "$NPM_USER" != "$EXPECTED_USER" ]] && [[ "$NPM_USER" != *"$EXPECTED_USER"* ]]; then
              echo "⚠️  WARNING: NPM user '$NPM_USER' may not match scope '$PACKAGE_SCOPE'"
              echo "For scoped packages, the npm user must own the scope."
            fi
          fi
          
          echo ""
          echo "Checking if package exists..."
          if npm view "$PACKAGE_NAME" version 2>/dev/null; then
            echo "✓ Package exists on npm"
            echo "Checking publish access..."
            if npm access ls-packages 2>/dev/null | grep -q "$PACKAGE_NAME"; then
              echo "✓ You have publish access to this package"
            else
              echo "⚠️  Package exists but you may not have publish access"
            fi
          else
            echo "Package does not exist (first publish)"
          fi
      - name: Publish to npm
        run: |
          # Try to publish, but handle the case where package doesn't exist (first publish)
          npm publish --access public || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 1 ]; then
              echo "Publish failed. Common causes:"
              echo "1. Package name might be taken by another account"
              echo "2. npm token might not have publish permissions"
              echo "3. Authentication issue - verify npm_token secret is correct"
              exit $EXIT_CODE
            fi
            exit $EXIT_CODE
          }
